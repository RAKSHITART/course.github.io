<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Design and Analysis of Algorithms</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <header>
        <h1>Design and Analysis of Algorithms</h1>
        <p>Course Overview: An in-depth exploration of the core principles behind algorithms and data structures.</p>
    </header>
    
    <section>
        <h2>Course Highlights</h2>
        <ul>
            <li><strong>Core Principles:</strong> Investigate time and space complexities, recursive strategies, and backtracking methods.</li>
            <li><strong>Advanced Data Structures:</strong> Gain expertise in hashing techniques, Union-Find operations, AVL Trees, Segment Trees, and Red-Black Trees.</li>
            <li><strong>Optimized Algorithms:</strong> Learn efficient sorting and searching approaches such as Quick Sort, KMP, and Rabin-Karp algorithms.</li>
            <li><strong>Graph-Based Solutions:</strong> Study algorithms for shortest paths like Dijkstra’s, spanning trees such as Prim’s, and complex challenges like the Travelling Salesperson Problem.</li>
            <li><strong>Theoretical Foundations:</strong> Explore NP-completeness and the inherent limitations of computational approaches.</li>
        </ul>
    </section>

    <section>
        <h2>Our Journey Through Algorithms</h2>
        <h3>Math Foundations</h3>
        <p>We began our exploration of algorithms by establishing a solid foundation in mathematics. These principles are crucial to understanding the fundamentals of algorithm design and analysis. Our focus started with concepts like time and space efficiency, where we learned to calculate and analyze these metrics for various solutions and recurrence relations. Problems like the Tower of Brahma and the N-Queens problem helped us apply these mathematical concepts practically.</p>
        
        <h3>Orders of Growth</h3>
        <p>The journey continued with a deeper dive into the mathematical principles behind the orders of growth. This understanding allowed us to assess and compare the efficiency of different solutions in greater detail, laying the groundwork for evaluating algorithm performance.</p>

        <h3>Structured Data Management</h3>
        <p>Next, we ventured into the realm of structured data, focusing on how to organize and manage it effectively. The journey began with binary trees, which evolved into binary search trees when combined with searching algorithms. From there, we encountered 2-3 trees, which led us to study AVL trees as a solution to reduce imbalances. To enhance performance for operations like insertion and deletion, we explored Red-Black trees. Additional structures like Tries and Skip Lists introduced efficient methods for data manipulation, with Skip Lists excelling in quick insertions and Tries leveraging pointers for compact storage.</p>

        <p>We also delved into Fenwick/Binary Indexed Trees (BIT), which operate on 1-based indexing, and studied heaps, including their mechanisms and associated algorithms. This section concluded with graph traversal techniques like BFS and DFS, which, despite their complexity, are indispensable for solving advanced algorithmic problems.</p>

        <h3>Key Takeaways</h3>
        <p>This foundational knowledge has equipped us with the tools to explore the vast and exciting world of algorithms, setting the stage for tackling more intricate challenges ahead.</p>
    </section>

    <section>
        <h2>Data Structures Overview</h2>
        <h3>Linear Data Structures</h3>
        <ul>
            <li><strong>Arrays:</strong> A collection of elements stored in contiguous memory locations.</li>
            <li><strong>Stacks:</strong> A Last-In-First-Out (LIFO) data structure for managing elements.</li>
            <li><strong>Queues:</strong> A First-In-First-Out (FIFO) data structure for processing elements.</li>
        </ul>

        <h3>Trees</h3>
        <ul>
            <li><strong>Trees:</strong> A hierarchical structure with nodes connected by edges.</li>
            <li><strong>Binary Search Trees (BST):</strong> A tree where each node has at most two children, with left < parent < right.</li>
            <li><strong>AVL Trees:</strong> A self-balancing binary search tree with height difference ≤ 1 between subtrees.</li>
            <li><strong>Red-Black Trees:</strong> A self-balancing BST with additional rules for node colors to maintain balance.</li>
            <li><strong>2-3 Trees:</strong> A balanced search tree where each node has 2 or 3 children.</li>
            <li><strong>Tries:</strong> A tree for storing strings, where each node represents a character.</li>
        </ul>

        <h3>Graph Structures</h3>
        <ul>
            <li><strong>Adjacency Matrix and List Representations:</strong> Ways to represent graphs using matrices or linked lists.</li>
            <li><strong>Directed and Undirected Graphs:</strong> Graphs with edges having direction (directed) or no direction (undirected).</li>
        </ul>

        <h3>Specialized Structures</h3>
        <ul>
            <li><strong>Heaps:</strong> A tree-based structure where the parent node is always larger (max-heap) or smaller (min-heap) than its children.</li>
            <li><strong>Fenwick Trees (Binary Indexed Trees):</strong> A data structure for efficiently updating and querying prefix sums.</li>
            <li><strong>Segment Trees:</strong> A tree used for range queries and updates on an array.</li>
            <li><strong>Sparse Tables:</strong> A structure for efficient range queries, usually for static arrays.</li>
            <li><strong>Skip Lists:</strong> A linked list with additional layers for faster search, insert, and delete operations.</li>
        </ul>
    </section>

    <section>
        <h2>Project Overview</h2>
        <p>In this project, we set out to apply the algorithms and concepts we studied in our course to a real-world scenario: mall management. Here's how we approached it:</p>

        <h3>Concepts Applied</h3>
        <ul>
            <li><strong>Finding Shortest Routes to the Mall:</strong> We used Dijkstra's Algorithm to help visitors find the shortest and most efficient routes to the mall from their locations.</li>
            <li><strong>Planning Emergency Evacuation:</strong> For safety, we employed Breadth-First Search (BFS) and Depth-First Search (DFS) to map out emergency evacuation routes within the mall. This ensures that people can exit safely and quickly in case of an emergency.</li>
            <li><strong>Tracking Mall Revenue:</strong> Using a Binary Search Tree (BST), we organized and tracked revenue data for the mall’s stores. This allowed us to analyze trends and monitor performance efficiently.</li>
            <li><strong>Ranking Store Popularity:</strong> To rank stores based on their popularity or sales, we implemented Merge Sort, ensuring accurate and efficient sorting of data.</li>
            <li><strong>Optimizing ATM Placement:</strong> To decide where ATMs should be placed for maximum accessibility, we applied Floyd’s Algorithm, allowing us to identify optimal locations that minimize walking distance for visitors.</li>
            <li><strong>Mapping Wi-Fi Coverage Zones:</strong> By using Kruskal’s Algorithm, we designed Wi-Fi coverage zones within the mall, ensuring minimal overlap and maximum connectivity.</li>
        </ul>
    </section>

    <footer>
        <p>&copy; 2024 Design and Analysis of Algorithms Course. All rights reserved.</p>
    </footer>
</body>
</html>
